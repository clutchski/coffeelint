#!/usr/bin/env node
// Generated by CoffeeScript 1.3.3

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
*/


(function() {
  var CSVReporter, ErrorReport, JSLintReporter, Reporter, coffeelint, config, configPath, data, errorReport, findCoffeeScripts, fs, glob, lintFiles, lintSource, optimist, options, path, paths, read, reportAndExit, scripts, stdin, thisdir,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  path = require("path");

  fs = require("fs");

  glob = require("glob");

  optimist = require("optimist");

  thisdir = path.dirname(fs.realpathSync(__filename));

  coffeelint = require(path.join(thisdir, "..", "lib", "coffeelint"));

  read = function(path) {
    var realPath;
    realPath = fs.realpathSync(path);
    return fs.readFileSync(realPath).toString();
  };

  findCoffeeScripts = function(paths) {
    var files, p, _i, _len;
    files = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      if (fs.statSync(p).isDirectory()) {
        files = files.concat(glob.sync("" + p + "/**/*.coffee"));
      } else {
        files.push(p);
      }
    }
    return files;
  };

  ErrorReport = (function() {

    function ErrorReport() {
      this.paths = {};
    }

    ErrorReport.prototype.getExitCode = function() {
      for (path in this.paths) {
        if (this.pathHasError(path)) {
          return 1;
        }
      }
      return 0;
    };

    ErrorReport.prototype.getSummary = function() {
      var error, errorCount, errors, pathCount, warningCount, _i, _len, _ref;
      pathCount = errorCount = warningCount = 0;
      _ref = this.paths;
      for (path in _ref) {
        errors = _ref[path];
        pathCount++;
        for (_i = 0, _len = errors.length; _i < _len; _i++) {
          error = errors[_i];
          if (error.level === 'error') {
            errorCount++;
          }
          if (error.level === 'warn') {
            warningCount++;
          }
        }
      }
      return {
        errorCount: errorCount,
        warningCount: warningCount,
        pathCount: pathCount
      };
    };

    ErrorReport.prototype.getErrors = function(path) {
      return this.paths[path];
    };

    ErrorReport.prototype.pathHasWarning = function(path) {
      return this._hasLevel(path, 'warn');
    };

    ErrorReport.prototype.pathHasError = function(path) {
      return this._hasLevel(path, 'error');
    };

    ErrorReport.prototype._hasLevel = function(path, level) {
      var error, _i, _len, _ref;
      _ref = this.paths[path];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        if (error.level === level) {
          return true;
        }
      }
      return false;
    };

    return ErrorReport;

  })();

  Reporter = (function() {

    function Reporter(errorReport, colorize) {
      if (colorize == null) {
        colorize = true;
      }
      this.errorReport = errorReport;
      this.colorize = colorize;
      this.ok = '✓';
      this.warn = '⚡';
      this.err = '✗';
    }

    Reporter.prototype.stylize = function() {
      var map, message, styles;
      message = arguments[0], styles = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!this.colorize) {
        return message;
      }
      map = {
        bold: [1, 22],
        yellow: [33, 39],
        green: [32, 39],
        red: [31, 39]
      };
      return styles.reduce(function(m, s) {
        return "\u001b[" + map[s][0] + "m" + m + "\u001b[" + map[s][1] + "m";
      }, message);
    };

    Reporter.prototype.publish = function() {
      var errors, summary, _ref;
      this.print("");
      _ref = this.errorReport.paths;
      for (path in _ref) {
        errors = _ref[path];
        this.reportPath(path, errors);
      }
      summary = this.errorReport.getSummary();
      this.reportSummary(summary);
      this.print("");
      return this;
    };

    Reporter.prototype.reportSummary = function(s) {
      var e, err, file, msg, p, start, w, warn;
      start = s.errorCount > 0 ? "" + this.err + " " + (this.stylize("Lint!", 'red', 'bold')) : s.warningCount > 0 ? "" + this.warn + " " + (this.stylize("Warning!", 'yellow', 'bold')) : "" + this.ok + " " + (this.stylize("Ok!", 'green', 'bold'));
      e = s.errorCount;
      w = s.warningCount;
      p = s.pathCount;
      err = this.plural('error', e);
      warn = this.plural('warning', w);
      file = this.plural('file', p);
      msg = "" + start + " » " + e + " " + err + " and " + w + " " + warn + " in " + p + " " + file;
      return this.print("\n" + this.stylize(msg));
    };

    Reporter.prototype.reportPath = function(path, errors) {
      var color, e, hasError, hasWarning, msg, o, overall, _i, _len, _ref, _results;
      _ref = (hasError = this.errorReport.pathHasError(path)) ? [this.err, 'red'] : (hasWarning = this.errorReport.pathHasWarning(path)) ? [this.warn, 'yellow'] : [this.ok, 'green'], overall = _ref[0], color = _ref[1];
      if (!options.argv.q || hasError) {
        this.print("  " + overall + " " + (this.stylize(path, color, 'bold')));
      }
      _results = [];
      for (_i = 0, _len = errors.length; _i < _len; _i++) {
        e = errors[_i];
        if (options.argv.q && e.level !== 'error') {
          continue;
        }
        o = e.level === 'error' ? this.err : this.warn;
        msg = "     " + ("" + o + " " + (this.stylize("#" + e.lineNumber, color)) + ": " + e.message + ".");
        if (e.context) {
          msg += " " + e.context + ".";
        }
        _results.push(this.print(msg));
      }
      return _results;
    };

    Reporter.prototype.print = function(message) {
      return console.log(message);
    };

    Reporter.prototype.plural = function(str, count) {
      if (count === 1) {
        return str;
      } else {
        return "" + str + "s";
      }
    };

    return Reporter;

  })();

  CSVReporter = (function(_super) {

    __extends(CSVReporter, _super);

    function CSVReporter() {
      return CSVReporter.__super__.constructor.apply(this, arguments);
    }

    CSVReporter.prototype.publish = function() {
      var e, errors, f, _ref, _results;
      _ref = this.errorReport.paths;
      _results = [];
      for (path in _ref) {
        errors = _ref[path];
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            e = errors[_i];
            f = [path, e.lineNumber, e.level, e.message];
            _results1.push(this.print(f.join(",")));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return CSVReporter;

  })(Reporter);

  JSLintReporter = (function(_super) {

    __extends(JSLintReporter, _super);

    function JSLintReporter() {
      return JSLintReporter.__super__.constructor.apply(this, arguments);
    }

    JSLintReporter.prototype.publish = function() {
      var e, errors, _i, _len, _ref;
      this.print("<?xml version=\"1.0\" encoding=\"utf-8\"?><jslint>");
      _ref = this.errorReport.paths;
      for (path in _ref) {
        errors = _ref[path];
        if (errors.length) {
          this.print("<file name=\"" + path + "\">");
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            e = errors[_i];
            this.print("<issue line=\"" + e.lineNumber + "\"\n        reason=\"[" + (this.escape(e.level)) + "] " + (this.escape(e.message)) + "\"\n        evidence=\"" + (this.escape(e.context)) + "\"/>");
          }
          this.print("</file>");
        }
      }
      return this.print("</jslint>");
    };

    JSLintReporter.prototype.escape = function(msg) {
      var r, replacements, _i, _len;
      msg = "" + msg;
      if (!msg) {
        return;
      }
      replacements = [[/&/g, "&amp;"], [/"/g, "&quot;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/'/g, "&apos;"]];
      for (_i = 0, _len = replacements.length; _i < _len; _i++) {
        r = replacements[_i];
        msg = msg.replace(r[0], r[1]);
      }
      return msg;
    };

    return JSLintReporter;

  })(Reporter);

  lintFiles = function(paths, config) {
    var errorReport, source, _i, _len;
    errorReport = new ErrorReport();
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      path = paths[_i];
      source = read(path);
      errorReport.paths[path] = coffeelint.lint(source, config);
    }
    return errorReport;
  };

  lintSource = function(source, config) {
    var errorReport;
    errorReport = new ErrorReport();
    errorReport.paths["stdin"] = coffeelint.lint(source, config);
    return errorReport;
  };

  reportAndExit = function(errorReport, options) {
    var colorize, reporter,
      _this = this;
    reporter = options.argv.jslint ? new JSLintReporter(errorReport) : options.argv.csv ? new CSVReporter(errorReport) : (colorize = !options.argv.nocolor, new Reporter(errorReport, colorize));
    reporter.publish();
    process.stdout.on('drain', function() {
      return process.exit(errorReport.getExitCode());
    });
    return process.stderr.on('drain', function() {
      return process.exit(errorReport.getExitCode());
    });
  };

  options = optimist.usage("Usage: coffeelint [options] source [...]").alias("f", "file").alias("h", "help").alias("v", "version").alias("s", "stdin").alias("q", "quiet").describe("f", "Specify a custom configuration file.").describe("h", "Print help information.").describe("v", "Print current version number.").describe("r", "Recursively lint .coffee files in subdirectories.").describe("csv", "Use the csv reporter.").describe("jslint", "Use the JSLint XML reporter.").describe("nocolor", "Don't colorize the output").describe("s", "Lint the source from stdin").describe("q", "Only print errors.").boolean("csv").boolean("jslint").boolean("nocolor").boolean("r").boolean("s").boolean("q", "Print errors only.");

  if (options.argv.v) {
    console.log(coffeelint.VERSION);
    process.exit(0);
  } else if (options.argv.h) {
    options.showHelp();
    process.exit(0);
  } else if (options.argv._.length < 1 && !options.argv.s) {
    options.showHelp();
    process.exit(1);
  } else {
    configPath = options.argv.f;
    config = configPath ? JSON.parse(read(configPath)) : {};
    if (options.argv.s) {
      data = '';
      stdin = process.openStdin();
      stdin.on('data', function(buffer) {
        if (buffer) {
          return data += buffer.toString();
        }
      });
      stdin.on('end', function() {
        var errorReport;
        errorReport = lintSource(data, config);
        return reportAndExit(errorReport, options);
      });
    } else {
      paths = options.argv._;
      scripts = options.argv.r ? findCoffeeScripts(paths) : paths;
      errorReport = lintFiles(scripts, config);
      reportAndExit(errorReport, options);
    }
  }

}).call(this);
