// Generated by CoffeeScript 1.6.3
(function() {
  var MissingFatArrows, any, isClass, isCode, isFatArrowCode, isObject, isThis, isValue, methodsOfClass, needsFatArrow,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  isCode = function(node) {
    return (node != null ? node.constructor.name : void 0) === 'Code';
  };

  isClass = function(node) {
    return node.constructor.name === 'Class';
  };

  isValue = function(node) {
    return node.constructor.name === 'Value';
  };

  isObject = function(node) {
    return node.constructor.name === 'Obj';
  };

  isThis = function(node) {
    return isValue(node) && node.base.value === 'this';
  };

  isFatArrowCode = function(node) {
    return isCode(node) && node.bound;
  };

  any = function(arr, test) {
    return arr.reduce((function(res, elt) {
      return res || test(elt);
    }), false);
  };

  needsFatArrow = function(node) {
    return isCode(node) && (any(node.params, function(param) {
      return param.contains(isThis) != null;
    }) || (node.body.contains(isThis) != null));
  };

  methodsOfClass = function(classNode) {
    var bodyNodes, returnNode;
    bodyNodes = classNode.body.expressions;
    returnNode = bodyNodes[bodyNodes.length - 1];
    if ((returnNode != null) && isValue(returnNode) && isObject(returnNode.base)) {
      return returnNode.base.properties.map(function(assignNode) {
        return assignNode.value;
      }).filter(isCode);
    } else {
      return [];
    }
  };

  module.exports = MissingFatArrows = (function() {
    function MissingFatArrows() {}

    MissingFatArrows.prototype.rule = {
      name: 'missing_fat_arrows',
      level: 'ignore',
      message: 'Used `this` in a function without a fat arrow',
      description: "Warns when you use `this` inside a function that wasn't defined\nwith a fat arrow. This rule does not apply to methods defined in a\nclass, since they have `this` bound to the class instance (or the\nclass itself, for class methods).\n\nIt is impossible to statically determine whether a function using\n`this` will be bound with the correct `this` value due to language\nfeatures like `Function.prototype.call` and\n`Function.prototype.bind`, so this rule may produce false positives."
    };

    MissingFatArrows.prototype.lintAST = function(node, astApi) {
      this.lintNode(node, astApi);
      return void 0;
    };

    MissingFatArrows.prototype.lintNode = function(node, astApi, methods) {
      var error,
        _this = this;
      if (methods == null) {
        methods = [];
      }
      if ((!isFatArrowCode(node)) && (__indexOf.call(methods, node) < 0) && (needsFatArrow(node))) {
        error = astApi.createError({
          lineNumber: node.locationData.first_line + 1
        });
        this.errors.push(error);
      }
      return node.eachChild(function(child) {
        return _this.lintNode(child, astApi, (function() {
          switch (false) {
            case !isClass(node):
              return methodsOfClass(node);
            case !isCode(node):
              return [];
            default:
              return methods;
          }
        })());
      });
    };

    return MissingFatArrows;

  })();

}).call(this);
