// Generated by CoffeeScript 1.6.3
(function() {
  var Indentation;

  module.exports = Indentation = (function() {
    Indentation.prototype.rule = {
      name: 'indentation',
      value: 2,
      level: 'error',
      message: 'Line contains inconsistent indentation',
      description: "This rule imposes a standard number of spaces to be used for\nindentation. Since whitespace is significant in CoffeeScript, it's\ncritical that a project chooses a standard indentation format and\nstays consistent. Other roads lead to darkness. <pre> <code>#\nEnabling this option will prevent this ugly\n# but otherwise valid CoffeeScript.\ntwoSpaces = () ->\n  fourSpaces = () ->\n      eightSpaces = () ->\n            'this is valid CoffeeScript'\n\n</code>\n</pre>\nTwo space indentation is enabled by default."
    };

    Indentation.prototype.tokens = ['INDENT', "[", "]"];

    function Indentation() {
      this.arrayTokens = [];
    }

    Indentation.prototype.lintToken = function(token, tokenApi) {
      var currentLine, expected, ignoreIndent, isArrayIndent, isInterpIndent, isMultiline, lineNumber, lines, numIndents, prevNum, previous, previousIndentation, previousLine, previousSymbol, type, _ref;
      type = token[0], numIndents = token[1], lineNumber = token[2];
      if (type === "[" || type === "]") {
        this.lintArray(token);
        return void 0;
      }
      if (token.generated != null) {
        return null;
      }
      previous = tokenApi.peek(-2);
      isInterpIndent = previous && previous[0] === '+';
      previous = tokenApi.peek(-1);
      isArrayIndent = this.inArray() && (previous != null ? previous.newLine : void 0);
      previousSymbol = (_ref = tokenApi.peek(-1)) != null ? _ref[0] : void 0;
      isMultiline = previousSymbol === '=' || previousSymbol === ',';
      ignoreIndent = isInterpIndent || isArrayIndent || isMultiline;
      if (this.isChainedCall(tokenApi)) {
        lines = tokenApi.lines, lineNumber = tokenApi.lineNumber;
        currentLine = lines[lineNumber];
        prevNum = 1;
        while (/^\s*(#|$)/.test(lines[lineNumber - prevNum])) {
          prevNum += 1;
        }
        previousLine = lines[lineNumber - prevNum];
        previousIndentation = previousLine.match(/^(\s*)/)[1].length;
        numIndents = currentLine.match(/^(\s*)/)[1].length;
        numIndents -= previousIndentation;
      }
      expected = tokenApi.config[this.rule.name].value;
      if (!ignoreIndent && numIndents !== expected) {
        return {
          context: "Expected " + expected + " got " + numIndents
        };
      }
    };

    Indentation.prototype.inArray = function() {
      return this.arrayTokens.length > 0;
    };

    Indentation.prototype.lintArray = function(token) {
      if (token[0] === '[') {
        this.arrayTokens.push(token);
      } else if (token[0] === ']') {
        this.arrayTokens.pop();
      }
      return null;
    };

    Indentation.prototype.isChainedCall = function(tokenApi) {
      var i, lastNewLineIndex, lines, t, token, tokens;
      tokens = tokenApi.tokens, i = tokenApi.i;
      lines = (function() {
        var _i, _len, _ref, _results;
        _ref = tokens.slice(0, +i + 1 || 9e9);
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          token = _ref[i];
          if (token.newLine != null) {
            _results.push(i);
          }
        }
        return _results;
      })();
      lastNewLineIndex = lines ? lines[lines.length - 2] : null;
      if (lastNewLineIndex == null) {
        return false;
      }
      tokens = [tokens[lastNewLineIndex], tokens[lastNewLineIndex + 1]];
      return !!((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tokens.length; _i < _len; _i++) {
          t = tokens[_i];
          if (t && t[0] === '.') {
            _results.push(t);
          }
        }
        return _results;
      })()).length;
    };

    return Indentation;

  })();

}).call(this);
