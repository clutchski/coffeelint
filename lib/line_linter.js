// Generated by CoffeeScript 1.6.3
(function() {
  var BaseLinter, LineApi, LineLinter, configStatement,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  LineApi = (function() {
    function LineApi(source, config, tokensByLine, literate) {
      this.config = config;
      this.tokensByLine = tokensByLine;
      this.literate = literate;
      this.line = null;
      this.lines = source.split('\n');
      this.lineCount = this.lines.length;
      this.context = {
        "class": {
          inClass: false,
          lastUnemptyLineInClass: null,
          classIndents: null
        }
      };
    }

    LineApi.prototype.lineNumber = 0;

    LineApi.prototype.isLiterate = function() {
      return this.literate;
    };

    LineApi.prototype.maintainClassContext = function(line) {
      if (this.context["class"].inClass) {
        if (this.lineHasToken('INDENT')) {
          this.context["class"].classIndents++;
        } else if (this.lineHasToken('OUTDENT')) {
          this.context["class"].classIndents--;
          if (this.context["class"].classIndents === 0) {
            this.context["class"].inClass = false;
            this.context["class"].classIndents = null;
          }
        }
        if (this.context["class"].inClass && !line.match(/^\s*$/)) {
          this.context["class"].lastUnemptyLineInClass = this.lineNumber;
        }
      } else {
        if (!line.match(/\\s*/)) {
          this.context["class"].lastUnemptyLineInClass = null;
        }
        if (this.lineHasToken('CLASS')) {
          this.context["class"].inClass = true;
          this.context["class"].lastUnemptyLineInClass = this.lineNumber;
          this.context["class"].classIndents = 0;
        }
      }
      return null;
    };

    LineApi.prototype.isLastLine = function() {
      return this.lineNumber === this.lineCount - 1;
    };

    LineApi.prototype.lineHasToken = function(tokenType, lineNumber) {
      var token, tokens, _i, _len;
      if (tokenType == null) {
        tokenType = null;
      }
      if (lineNumber == null) {
        lineNumber = null;
      }
      lineNumber = lineNumber != null ? lineNumber : this.lineNumber;
      if (tokenType == null) {
        return this.tokensByLine[lineNumber] != null;
      } else {
        tokens = this.tokensByLine[lineNumber];
        if (tokens == null) {
          return null;
        }
        for (_i = 0, _len = tokens.length; _i < _len; _i++) {
          token = tokens[_i];
          if (token[0] === tokenType) {
            return true;
          }
        }
        return false;
      }
    };

    LineApi.prototype.getLineTokens = function() {
      return this.tokensByLine[this.lineNumber] || [];
    };

    return LineApi;

  })();

  BaseLinter = require('./base_linter.coffee');

  configStatement = /coffeelint:\s*(disable|enable)(?:=([\w\s,]*))?/;

  module.exports = LineLinter = (function(_super) {
    __extends(LineLinter, _super);

    LineLinter.configStatement = configStatement;

    function LineLinter(source, config, rules, tokensByLine, literate) {
      if (literate == null) {
        literate = false;
      }
      LineLinter.__super__.constructor.call(this, source, config, rules);
      this.lineApi = new LineApi(source, config, tokensByLine, literate);
      this.block_config = {
        enable: {},
        disable: {}
      };
    }

    LineLinter.prototype.acceptRule = function(rule) {
      return typeof rule.lintLine === 'function';
    };

    LineLinter.prototype.lint = function() {
      var error, errors, line, lineNumber, _i, _j, _len, _len1, _ref, _ref1;
      errors = [];
      _ref = this.lineApi.lines;
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        line = _ref[lineNumber];
        this.lineApi.lineNumber = this.lineNumber = lineNumber;
        this.lineApi.maintainClassContext(line);
        this.collectInlineConfig(line);
        _ref1 = this.lintLine(line);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          error = _ref1[_j];
          errors.push(error);
        }
      }
      return errors;
    };

    LineLinter.prototype.lintLine = function(line) {
      var errors, rule, v, _i, _len, _ref;
      errors = [];
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        v = this.normalizeResult(rule, rule.lintLine(line, this.lineApi));
        if (v != null) {
          errors.push(v);
        }
      }
      return errors;
    };

    LineLinter.prototype.collectInlineConfig = function(line) {
      var cmd, r, result, rules, _i, _len, _ref;
      result = configStatement.exec(line);
      if (result != null) {
        cmd = result[1];
        rules = [];
        if (result[2] != null) {
          _ref = result[2].split(',');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            r = _ref[_i];
            rules.push(r.replace(/^\s+|\s+$/g, ""));
          }
        }
        this.block_config[cmd][this.lineNumber] = rules;
      }
      return null;
    };

    LineLinter.prototype.createError = function(rule, attrs) {
      var _ref;
      if (attrs == null) {
        attrs = {};
      }
      attrs.lineNumber = this.lineNumber + 1;
      attrs.level = (_ref = this.config[rule]) != null ? _ref.level : void 0;
      return LineLinter.__super__.createError.call(this, rule, attrs);
    };

    return LineLinter;

  })(BaseLinter);

}).call(this);
